import { rgb } from "color-convert";
import { resolve } from "node:path";
import { Parser } from "xml2js";

const itermColorsFilePath = resolve(
  import.meta.dir,
  "..",
  "dogwater.itermcolors"
);

const itermColorsFile = Bun.file(itermColorsFilePath);

const parser = new Parser();
const unparsedItermColors = await itermColorsFile.text();

const parsedItermColors = await parser.parseStringPromise(unparsedItermColors);

const {
  dict: colorSRGBDefinitions,
  key: colorNames,
}: { dict: { real: string[] }[]; key: string[] } =
  parsedItermColors.plist.dict[0];

const itermColors = colorNames.map((colorName, i) => {
  const [a, b, g, r] = colorSRGBDefinitions[i].real;

  return {
    a: parseFloat(a),
    b: parseFloat(b) * 255,
    g: parseFloat(g) * 255,
    name: colorName,
    r: parseFloat(r) * 255,
  };
});

// Make sure that the "ANSI N" color names are sorted correctly.
itermColors.sort((a, b) =>
  a.name.localeCompare(b.name, undefined, { numeric: true })
);

function toSnakeCase(spaceDelimitedString: string) {
  return spaceDelimitedString
    .toLowerCase()
    .split(/\s+/)
    .map((word) => word.toLowerCase())
    .join("_");
}

const palette = [
  "-- DO NOT MODIFY: this file is generated by scripts/generate-palette.ts",
  "",
  "local dogwater_palette = {",
  itermColors
    .map(
      ({ b, g, name, r }) => `  ${toSnakeCase(name)} = "#${rgb.hex(r, g, b)}"`
    )
    .join(",\n"),
  "}",
  "",
  "return dogwater_palette",
  "",
].join("\n");

const paletteFilePath = resolve(
  import.meta.dir,
  "..",
  "lua",
  "palette_gen.lua"
);

await Bun.write(paletteFilePath, palette);
